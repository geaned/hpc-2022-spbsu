# Лекция 5

## Виды синхронизации

Рассмотрим односвязный отсортированный список, у каждого элемента которого есть идентификатор (целое число, по которому осуществляется сортировка). Список поддерживает операции вставки, удаления и проверки началия элемента. Хотим сделать эту структуру потокобезопасной, у чего есть разные способы:
- **грубая синхронизация**: что бы мы ни делали со структурой, на время работы с ней мы захватываем примитив

- **тонкая синхронизация**: отдельный примитив синхронизации на каждый элемент

В таком случае нужно отдельно думать, какие примитивы захватывать. В нашем случае нужно переод окончанием работы с элементом захватить примитив у следующего, иначе будет промежуток времени, в который поток может заснуть, а другие потоки смогут сделать со структурой все, что угодно.

Рассмотрим отдельно операции вставки и удаления. При удалении, во-первых нужно захватывать примитив удаляемого элемента, поскольку может произойти ситуация, при которой удаляющий поток встанет на инструкции, перекидывающей ссылку с удаляемого элемента на следующий, а в это время другой поток начнет добавлять элементы после удаляемого, и после перекидывания ссылки все эти элементы пропадут. Также ясно, что примитив нужно захватывать и у элемента, у которого мы меняем ссылку на следующий. **[Пример?]**

При вставке достаточно захватывать только элемент, после которого мы хотим осуществить добавление нового элемента.

*Поскольку мы и так захватываем элементы парами, пока идем по структуре данных, ничего страшного, если при вставке мы еще и заблокируем следующий после вставляемого элемент.*

Этот способ быстрее, но имеет аналогичную проблему с тем, что один поток может захватить некоторый примитив и из-за этого другие потоки встанут на этом захвате. Может вообще обойтись без примитивов?

- **оптимистичная синхронизация**: при любом методе идем по списку без синхронизации, а захватываем, только когда нашли место операции

Допустим, мы нашли место без синхронизации, захватили оба элемента, но никто не гарантирует, что в структуре эти элементы все еще идут подряд. Нужно проверить, что:
- первый из двух все еще ссылается на второй (тривиальная проверка)
- эти элементы все еще в списке (элементы уже захвачены; идем с самого начала, если снова находим их, то они действительно еще в списке)

При таком походе потоки могут встать только в случае, когда доходят до места, в котором сейчас реально меняется содержимое структуры. Однако мы платим за это увеличением процессорного времени и возможностью того, что некоторые "невезучие" потоки будут много раз перезапускать операцию перед тем, как им удастся ее выполнить.

*Не стоит сильно задумываться над тем, что можно делать с "невезучими" потоками, поскольку каждый раз как один поток перезапускает операцию, это означает, что с другого операция прошла успешно.*

- **ленивая синхронизация**: при удалении элемента поднимаем в нем специальный флаг перед тем, как фактически перенести ссылку; теперь вместо прохода с самого начала достаточно проверить два флага после взятия примитивов у этих элементов

Все равно остается риск того, что поток, который взял примитив синхронизации у некоторого элемента, будет снят с исполнения и пока его не вернут, остальные не смогут работать с элементами, которые стоят дальше в списке. Нужно, чтобы потоки работали независимо друг от друга.

- **неблокирующая (lock-free) синхронизация **: атомарно сменим флаг и указатель на следующий элемент с помощью CAS

*CAS может работать с 64-битными числами; для адресации на 64-битной машине используется 48 бит, поэтому флаг можно хранить вместе с флагом в одном числе.*

На примере вставки: пусть есть элементы `2` и `3`, между которыми мы хотим вставить `2.5`. Создаем элемент `{2.5, false}` и одним CAS пробуем поменять ссылку: `compare_and_set(2.next, {3,false}, {2.5,false})`. Каждый раз, как CAS не пройдет, повторяем с самого начала. При удалении аналгично, только вначале с помощью CAS мы поднимаем флаг, а во-втором CAS мы переставляем ссылку не на новый элемент, а на следующий за удаляемым.

*В такой постановке потоки помогают друг другу, поэтому если какой-либо поток при проходе по списку найдет элемент с поднятым флагом (логически удаленный), то он попробует убрать его из структры с помощью CAS.* 

На самом деле **любой контейнер можно сделать `lock-free`**: пока не получится, создаем коипю структуры, применяем мутацию и пробуем подменить структуру на измененную с помощью CAS. Но, безусловно, это очень непроизводительно.

*Примечание: некоторый аналог CAS можно встретить в фреймворках для ORM (object-relation mapping). Допустим, мы в запросили список учеников в электронном журнале и в течение дня выставляли им оценки; в это же время другие учителя могли запрашивать по одному ученику (например, вызывая их к доске), ставить оценки и сразу сохранять результат в базе. Дело в том, что ORM может объединять выбор данных и их обновление в транзакцию, и в случае поступления изменений в данных не с нашей стороны во время транзакции наши изменения нельзя будет сохранить (и ошибка эскалируется уже до уровня электронного журлана и выдает ошибку пользователю). За подробностями см. паттерн unit-of-work*

## Thread-local Storage

**TLS (thread-local storage)** --- механизм, с помощью которого каждый поток в процессе может выделять область памяти для хранения определенных данных потока.

*Самый старый пример TLS --- значение `errno`. Оно действительно свое для каждого потока.*

За то, что при завершении потока объекты, соответствующие этому потоку, корректно разрушаются, отвечает ОС. В реальной системе имеет смысл применить TLS в следующем случае: пусть есть приложение, пользующееся отдельно написанной бизнес-логикой через предоставляемый ей интерфейс, которая, в свою очередь, общается с БД через слой доступа к базе данных. Часто отдельно выделяют **анемичную модель области (anemic domain model)** (т.е. реализующая операции, связанные с хранением и передачи данных), использующаяся бизнес-логикой и слоем для работы с БД.

*Как правило бизнес-логика включает в себя именно реализацию  функциональных требований заказчика. Об этом можно думать, как о программном коде, который разработчику придется написать вне зависимости от принятых архитектурных решений.*

Обычно внутри слоя для работы с БД есть приватный метод получения хэндлера (с результатом, зависящим от привилегий пользователя). Также, пусть к нам приходит требование быстро выполнять много операций в нашем приложении, то есть, говоря нашим языком, нужно добавить многопоточность в продукт. Есть выбор: или прошивать многопоточную логику через все слои, включая добавление уникального для потока приватного метода получения хэндлера, или объявить структуру, которую возвращает метод, как thread-local --- будут создаваться разные хэндлеры, уникальные для каждого потока.
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTMxNDgzNDg0NF19
-->