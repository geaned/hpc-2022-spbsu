# Лекция 8

## Lock-free и wait-free алгоритм снятия снэпшота

Имеем два атомарных регистра, для которых необходимо **разработать lock-free алоритм** снятия снепшота. Снепшот должен обладать следующими свойствами:

- **актуальность**: снепшот должен был существовать хотя бы одно мгновение с момента отправки запроса на снятие
- **согласованность**: снепшот должен отображать некоторое общее состояние всех регистров, которое действительно имело место

Можно предложить наивный алгоритм:  последовательно брать значения всех регистров, пока не найдутся две одинаковые пары значений подряд. Он удовлетворяет первому свойству, но не второму из-за следующего возможного сценария (изначально в регистрах нули):

```
[1] Запускает scan()
[1] Считывает первое значение: 0
[2] Меняет значение первого регистра на 1
[2] Меняет значение второго регистра на 1
[1] Считывает второе значение: 1
[2] Меняет значение второго регистра на 0
[2] Меняет значение первого регистра на 0
[1] Считывает первое значение: 0
[2] Меняет значение первого регистра на 1
[2] Меняет значение второго регистра на 1
[1] Считывает второе значение: 1
[1] Возвращает снепшот {0,1}
```

Настоящее решение чуть более изощренное. Идея: вместе с каждым регистром храним его версию, тогда нам достаточно дождаться **двух последовательных одинаковых векторов версий** (атомарный регистр на то и атомарный, что полезную нагрузку и метаданные можно писать вместе). И этот алгоритм действительно lock-free.

Однако lock-free алгоритмы известны тем, что может случиться так, что какому-то потоку будет постоянно невезти. Поскольку иногда это может критически сказаться на системе, поставим новую задачу: **разработать wait-free алгоритм** (при этом wait-free должны быть как запись, так и снятие снепшота). Для простоты пусть каждый регистр подчиняется идеологии **SWMR (single writer multiple reader)**, то есть один поток меняет закрепленный за ним регистр.

Новое решение: добавим к каждому регистру не только версию, но и весь снепшот на момент перед последней записью в регистр. Осталось только понять, как снять сам снепшот. Случайный брать нельзя, так как может нарушиться первое требуемое свойство (мы даже не знаем, сколько времени могло пройти между взятием снепшота и его записью вместе с новыми значением и версией в регистр).

Пусть мы можем сразу считать все регистры wait-free (а именно вместе с версиями и ссылками на снэпшоты). Считаем их два раза вместе с векторами версий, если версии совпадают, получили снепшот, иначе какие-то версии различаются. Мы можем пометить регистр (или все регистры), в которых версии не равны, --- **в нем точно случилась запись после запуска** операции внятия снепшота. Повторяем это пока снепшоты не будут отличаться только в помеченных элементах; за счет SWMR в этот раз в структуре с любым из вновь измененных регистров мы найдем актуальный снепшот, поскольку мы точно знаем, что он начал браться после записи, из-за которой регистр был помечен и, как следует, после запуска операции взятия снепшота.

Стоит ли всюду использовать wait-free алгоритмы? **Нет, не стоит**, как минимум из-за очевидных издержек по памяти. На самом деле мы проигрываем и по средней производительности тоже как минимум потому, что заставляем каждый поток писатель записывать целый снепшот (потоки больше не помогают друг другу).
