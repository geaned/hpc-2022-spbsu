# Лекция 2

## Способы создания потока, их сравнение

**POSIX** (Portable Operating System Interface) --- это стандарт набора вызовов операционной системы (иначе, системных вызовов). **POSIX Threads** --- расширение POSIX, реализующее многопоточную работу в операционной системе. Названия всех функций этого расширения начинаются с `pthread_`. Потоки языков программирования (C++, Java и т.д.) инкапсулируют работу с потоками POSIX.

На Java поток создается как объект класса `Thread`, в который нужно передать объект, реализующий интерфейс `Runnable` (у которого, в свою очередь, есть виртуальная функция `run()`), после чего у `Thread` можно вызвать `start()`.

*Вообще необязательно, чтобы созданный вычислительный поток соответствовал вычислительному потоку ОС. Раньше JVM работала на одном потоке ОС, сколько бы потоков пользователь ни создал (см. green threads). Сейчас уже можно считать, что в подавляющем большинстве случаев есть соответствие один к одному между потоками ЯП и созданными ими потоками ОС.*

С другой стороны, можно отнаследоваться от самого `Thread`, переопределить метод `run()` у него и вызвать с помощью `start()`. Какой метод лучше? У первого метода есть техническое преимущество: возможна реализация нескольких интерфейсов вместе с `Runnable` через `implements`, в то время как множественное наследование от `Thread` вместе с чем-либо еще через `extends` в Java невозможно. В остальных же языках вопрос остается.

Более глубоко, когда мы проектируем программу, мы рассматриваем **объекты, их типы и степени связности между ними**. Существуют следующие степени связности (от самой слабой к самой сильной):

- агрегация --- содержание одним объектом в себе другого объектапредставленным любым вышестоящим объектом
- композиция --- агреграция с общим временем жизни объектов
- наследование --- использование того, что есть у класса-предка и изменение поведения с сохранением возможности каждого нижестоящего объекта быть
- дружественность --- предоставление одним объектом возможности делать абсолютно все со внутренностями другого объекта (`friend` в C++)

С точки зрения исключительно особенностей языка, в Java нет разницы между агрегацией и композицией, но логически она все же есть: если мы создаем объект как поле другого объекта и никогда его не возвращаем, мы можем быть уверены в том, что объекты скомпозированы.

*Почему дружественность самая сильная? Ее крайне сильно модифицировать, например, потому, что при рефакторинге даже изменение инициализации приватных полей класса может повлечь за собой необходимость менять код дружественного класса. К примеру, при наследовании можно обращаться только к `protected` и `public` полям. Далее, при композиции один объект содержит другой как член-данное, поэтому при рефакторинге достаточно рассматривать только публичный интерфейс.*

*Примечание: в C++ удобно рассматривать разницу между агрегацией и композицией как, соответственно, хранение объекта по ссылке и по указателю.*

Итак, при дизайне программного обеспечения необходимо изначально выбирать степени связности минимально возможной (но достаточной) силы. В нашем случае первая реализация предполагает агрегацию, а вторая --- наследование, поэтому смысл применять вторую реализацию есть только в случае, когда мы хотим изменить поведение самого потока.

## Завершение работы потока

Обычно, когда мы работаем с потоками, мы создаем поток, вызываем у него `start()`, а далее в некотором месте вызываем у него же `join()` и дожидаемся завершения его работы. А что будет, например, с потоками в C++, если выполнить только `start()`? Фактически, они будут убиты ОС в неопределенный момент времени, что бы они в это время ни делали.

А что, если поток выполняет какую-нибудь длительную операцию и через некоторое время нам перестал быть важен результат этой операции, а ресурсы, занимаемые потоком, нужны? Принудительно завершать поток не нужно, поскольку он может быть в неконсистентном состоянии; вместо этого можно "попросить" поток завершить работу с помощью `pthread_cancel()`, который выставляет специальный флаг в контексте потока, но **никто не гарантирует, что поток проверит этот флаг**.

По этой причине нужно аккуратно в многопоточных программах использовать библиотеки, не предполагающие многопоточную реализацию. Проверка флага осуществляется с помощью `pthread_testcancel()`, и в случае успешной проверки поток **больше ничего не выполнит**. Однако, иногда может понадобиться "сказать последнее слово", например, освободить примитивы синхронизации, корректно завершить работу с файлами и т.п., на случай чего существует функция `pthread_cleanup_push()` (и `phread_cleanup_pop()` для снятия, соответственно), которая принимает функцию без параметров (но это **не значит, что в нее нельзя ничего передать** - см. шаблон adapter), которая будет выполнена перед завершением работы потока из-за успеха `pthread_testcancel()`.

*Функция, которая внутри себя вызывает `pthread_testcancel()`, называется **cancellation point**. Более ста системных функций так же являются cancellation point.*

В частности, например, при достижении подобного "системного" cancellation point (или даже при вызове `pthread_testcancel()`) мы можем не быть готовы к завершению. На такой случай есть функция `pthread_setcancelstate()`, с помощью которой выставляется флаг на готовность к завершению. В случае выставленного флага все вызовы `pthread_testcancel()` будут отложены до повторной смены флага или до следующего cancellation point (зависит от значения `pthread_setcanceltype()`).

*В `pthread_cancel()` также можно передать идентификатор потока, который нужно завершить, а поскольку на потоках, в отличие от процессов, нет иерархической структуры, можно создать поток-диверсант, который будет пытаться завершить любой другой поток.*

## Механизм завершения потока в libc и Java

В libc в классе `pthread` есть `int pid`, `int tid` и `int cancelhandling`, который отвечает за все флаги, связанные с отменой работы (в частности `CANCELSTATE` и `CANCELTYPE`, которые уже рассматривались). Также в ней есть та самая функция `pthread_cancel()`, в которой меняется значение некоторого бита.

Поговорим о C++. До C++11 можно было использовать `boost::thread` (фактически перешедший в стандарт), в котором у потока был метод `interrupt()`, меняющий флаг, как в Java, и обработка которого изначально, как на Java, совершалась через поимку `boost::interrupted_exception`. Метод `sleep()` в `boost` не был адаптирован под механизмы POSIX и вначале проверял флаг (и выбрасывал исключение) или же вызывал системный `sleep()`, **который не был cancellation point**.

Уже в C++11 разобрались с этой проблемой так: просто не реализовали такой механизм, и только в C++20 появился настоящий аналог `interrupt()` в Java.

А как в Java? Посмотрим на код:

```java
while (!Thread.currentThread.isInterrupted()) {
	try {
		sleep(1000);
	} catch (InterruptedException e) {
		// обработка...
	}
}
```

Поскольку `InterruptedException` --- это **checked exception**, его нужно обрабатывать. Если `InterruptedException` пойман, то флаг завершенности работы потока сбрасывается и нет обязательства завершаться.

*Если же мы на Java из одного потока создали другой и во втором выкинулось исключение, то из первого потока мы никак не сможем его обработать. Если все же действсительно нужно это сделать, можно воспользоваться `setUncaughtExceptionHandler()`, в который передается функция, которая должна будет выполниться при исключении (действует глобально на весь процесс).*

**Задача**: пусть есть глобальная структура `ConcurrentLinQueue q` с большим количеством элементов и поток, выполняющий функцию:

```java
f() {
	try {
		q.poll();
		q.poll();
	} catch (InterruptedException e) {
		// обработка...
	}
}
```

Важно заметить, что функция `poll()` является interruption point. И пусть есть поток-диверсант, который выполняет:

```java
g() {
	while (true) {
		// interrupt(f)
	}
}
```

Как получить два элемента подряд без `InterruptedException`? Ведь в Java нет возможности, как в POSIX, сказать, что поток непрерываем.

**Ответ**: выполним тело `f()` в другом потоке, созданном внутри `f()`, а о нем поток, выполняющий `g()`, не знает.

## Работа с примитивами синхронизации

Допустим, мы бы сами писали примитив синхронизации. Нам нужен интерфейс типа `lock()` и `unlock()` (хотя бы для двух потоков). Первый пример:

```java
class LockOne implements Lock {
	private boolean[] flag = new boolean[2];

	public void lock() {
		int i = ThreadID.get();
		int j = 1 - i;	// ID другого потока
		flag[i] = true;
		while (flag[j]) {}
	}

	public void unlock() {
		int i = ThreadID.get();
		flag[i] = false;
	}
}
```

Тут есть ошибка. Если оба потока запишут флаг `true` подряд, то они оба застрянут на пустом цикле. Другой пример:

```java
class LockTwo implements Lock {
	private volatile int victim;

	public void lock() {
		int i = ThreadID.get();
		victim = i;	// "Я пойду последним."
		while (victim == i) {}
	}

	public void unlock() {}
```

С точки зрения техники здесь все в порядке, но логика хромает: поток получит ресурс только тогда, когда его захочет другой поток, который сам встанет на ожидание. Однако, можно добавить идею из этого примера в первый и получить рабочее решение:

```java
class Peterson implements Lock {
	private volatile boolean[] flag = new boolean[2];
	private volatile int victim;

	public void lock() {
		int i = ThreadID.get();
		int j = 1 - i;
		flag[i] = true;
		victim = i;
		while (flag[j] && victim == i) {}
	}

	public void unlock() {
		int i = ThreadID.get();
		flag[i] = false;
	}
}
```

Команду `victim = i` какой-то из потоков все же выполнит последним и встанет на ожидание, тем самым дав дорогу другому потоку, что решает проблему первого решения.

Данное решение можно распространить на произвольное количество потоков (код упрощен):
```java
class Bakery implements Lock {
	boolean[] flag;
	Label[] label;

	public Bakery(int n) {
		flag = new boolean[n];
		label = new Label[n];
		for (int i = 0; i < n; i++) {
			flag[i] = false;
			label[i] = 0;
		}
	}

	public void lock() {
		int i = ThreadID.get();
		flag[i] = true;
		label[i] = max(label) + 1;
		while (any(for k in (0, n): k != i && flag[k] && label[k] < label[i])) {}
	}

	public unlock() {
		flag[ThreadID.get()] = false;
}
```

Идея аналогичная: ждем, пока существует другой поток, **которому нужен ресурс и который попросил доступ раньше**.

## Класификация примитивов синхронизации: начало

Существуют нерекурсивные примитивы синхронизации (`mutex`) и рекурсивные (`recursive_mutex`). Разница состоит в том, что рекурсивный мьютекс внутри одного потока не встает, когда пытается захватить примитив повторно, а увеличивает счетчик (и освобождает примитв, когда счетчик упал до нуля). Рассмотрим пример:

```java
public class V<T> {
	recursive_mutex m;
	// ...
public:
	void add(T element) { // потокоопасная операция
		m.lock();
		// ...
		if (size() > 127) {
			reallocate();
		}
		/ ...
		m.unlock();
	}
	int size() { // потокоопасная операция
		m.lock();
		// ...
		m.unlock();
	}
}
```

Несмотря на то, что `size()` читает, он все равно может быть потокоопасен для структур данных с нетривиальной синхронизацией, и хранить размер как отдельную переменную для таких структур бывает некорректно. В этом случае необходим **рекурсивный мьютекс**. А как этого можно избежать без потери функциональности? Перенесем функциональность в функции `unsafe_add()` и `unsafe_size`, а публичные функции перепишем так:

```java
public class V<T> {
	mutex m;
	// ...
public:
	void add(T element) {
		m.lock();
		unsafe_add(element);
		m.unlock();
	}
	int size() {
		m.lock();
		unsafe_size();
		m.unlock();
	}
private:
	// unsafe_add и unsafe_size
}
```

На самом деле последний вариант лучше, поскольку он более тестируем: в первом случае тестирование многопоточной части смешивается с тестированием логики. Также подобное разбиение на многопоточную часть и логическую улучшает поддерживаемость.
<!--stackedit_data:
eyJoaXN0b3J5IjpbNzc4Nzk2OTg4XX0=
-->