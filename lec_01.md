# Лекция 1

## Введение в курс параллельного программирования

Существует два вида требований к системе:
- функциональные (что должна делать система?)
- **нефункциональные** (как должна делать система? --- время отклика, число обрабатываемых запросов в секунду и т.п.)

Этот курс именно про **нефункциональные** требования. Вообще производительность системы можно понимать с разных ракурсов (в зависимости он области применения):
- генетика и протеомика (эффективный доступ к большому объему общих данных + параллельные алгоритмы обработки этих данных)
- климатология (обработка больших данных на распределенных кластерах)
- физика высоких энергий (сохранение огромного объема данных + обработка на большом количестве кластеров, распределенных по миру)
- астрономия (аналогично предыдущему, много данных, к которым нужно эффективно применить однообразную обработку)
- банковские транзакции (в отличие от предыдущих примеров, нужно уметь максимально быстро обработать большое количество операций, поступающих непрерывно)

Поэтому для разных нужд есть разные технологии, позволяющие реализовать необходимое бизнес-решение. Более того, некоторые фреймворки вообще не предполагают высокой производительности.

## Каким бывает параллелизм

Пусть у нас есть одно ядро. Какой параллелизм мы уже имеем на этом уровне? **Ответ:** векторные расширения инструкций процессора:
- MMX (Multimedia Extensions)
- SSE (Streaming **SIMD** Extensions)
- AVX (Advanced Vector Extensions)
и так далее (вообще любые расширения процессора добавляют некоторый набор инструкций плюс, возможно, регистры)

Классификация вычислительных систем Майкла Флинна:
- SISD (single instruction single data)
- **SIMD** (single instruction multiple data)
- MISD (multiple instruction single data)
- MIMD (multiple instruction multiple data)

Какие знаем регистры? Например (32-битные):
- `EAX`, `EBX`, `ECX`, `EDX` - общего назначения
- `ESP` - указатель на стек
- `EIP` - указатель на текущую инструкцию

В SSE есть, например, 128-битные регистры `xmm0`, `xmm1`. Пример их использования:
```c
__asm {
	movups xmm0, a;
	movups xmm1, b;
	mulps xmm0, xmm1;
	movups a, xmm0;
};
```

В версии SSE 4.2 добавили строковые операции. Зачем? Все протоколы коммуникации основаны на XML, то есть так или иначе является болшими строками, поэтому фактически нужно было ускорить парсинг строк и эту функциональность спустили до уровня процессора.

Главное отличие MMX от SSE состоит в том, что MMX не умеет работать с числами с плавающей запятой - в мультимедиа просто нет такой необходимости, например, цветовые каналы кодируются целыми числами.

Если на машине есть больше одного ядра, то мы уже приходим к классическому многопоточному программированию:
- потоки операционной системы
- потоки на языках программирования
- OpenMP, TBB и т.д.

*Примечание: вообще абстракции потока и процесса появляются на уровне ОС. Можно написать программу, которая будет выполняться на процессоре и без нее.*

В операционных системах, как правило, используется **вытесняющая многозадачность** (ОС говорит, какой поток будет исполняться какое время, и меняет исполняемый поток по истечении времени); бывает еще кооперативная многозадачность (используется реже).

Для нас важно знать, что **существует процесс и потоки внутри него**. У процесса единое адресное пространство, которое разделяют потоки (если процесс попытается выйти за пределы этого пространства, его убьет ОС). С точки зрения ОС единица планирования работы процессора --- это именно поток, а процесс --- это контекст, содержащий, к примеру, таблицы дескрипторов открытых файлов, таблицы выделенных участков оперативной памяти и многое другое, который выделен для работы потоков. Также процесс обладает приоритетом, который наследуется потоками.

*Максимальным приоритетом обладает только процесс замещения страниц оперативной памяти (если программе нужно обратиться к данным не лежащим в оперативной памяти, необходимо вначале заместить данные в ней на актуальные, тем самым поддержав абстракцию непрерывного адресного пространства).*

## Межпоточное и межпроцессорное взаимодействие

Пусть мы пишем приложение, для которого недостаточно производительности одного потока, тогда перед нами встает выбор: использовать многопоточную технологию или огранизовать работу через несколько процессов --- **inter-process communication (IPC)**.

Механизмы IPC:
- shared memory (shmem)
- pipe
- файлы
- сокеты
- mmap
- сигналы

*Характерными отличиями сигналов является то, что, во-первых, мы не знаем, когда поток начнет обрабатывать сигнал, и, во-вторых, через сигналы нельзя передать дополнительные данные.*

Многопоточная реализация позволяет быстрее обращаться к памяти за счет того, что потоки в одном процессе имеют единое адресное пространство и, как следствие, у запрашиваемых ими физических адресов памяти по виртуальным адресам большая вероятность оказаться в **буфере ассоциативной трансляции** (translation lookaside buffer --- TLB) --- кэше таблицы соответствия адресов.

*Отсутствие вышеупомянутого преимущества не касается shmem.*

Плюсами многопроцессорной реализации являются **изолированность** (падение одной вкладки браузера не влияет на другие) и **безопасность** (данные одной вкладки браузера недоступны для другой). Из изолированности также следует **отказоустойчивость**.

В общем случае **реализация многопоточного приложения проще** даже с точки зрения количества кода, необходимого для реализации.

*Замечание по поводу сигналов: для того, чтобы пользователи тоже могли реализовывать свою логику на базе сигналов, существуют отдельные сигналы `SIGUSR1` и `SIGUSR2`. Примером утилиты, в которой обрабатывается `SIGUSR1` является `dd`. Если послать в него `kill -SIGUSR1 <PID>`, то процесс не завершится, а выведется статистика текущего копирования.*

## Закон Амдала

Закон Амдала численно говорит, в какое количество раз теоретически возможен прирост производительности в многопоточном приложении относительно его однопоточной реализации, и выражается формулой

$$
S = \frac{1}{a+\frac{1-a}{p}}
$$

где $a$ --- доля последовательного кода, $p$ --- число процессов. На деле он показывает **простую вещь**: последовательный код невозможно улучшить добавлением потоков к его исполнению.
